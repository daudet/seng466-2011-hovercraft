<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>SENG 466 Project 1</title>

<meta content="Mantis Cheng" name="author"></head><body style="width: 700px;">
<h1>SENG 466/CSC 578C Project 1</h1>
<br>
<span style="font-weight: bold;">Due Date</span>:
Friday, 4 February
2011.<br>
<br>
(<span style="font-weight: bold;">last modified</span>: 8
January
2011)<br>
<br>
<h2>* A Problem Statement for Our Course Projects</h2>
<div style="text-align: justify;">For this Spring of 2011,
we are
planning to design and build an autonomous hovercraft, more
specifically, a "zero" friction hovering craft lifted by one or more
small vertically-positioned propellers. The craft will be lifted by
the air
captured inside a "skirt" and filled by one or two larger propellers.
It should be able to carry a payload of around 1 to 1.5 Kg,&nbsp;
including all sensors, actuators,
mounting structures, controllers,&nbsp; the hovercraft itself and
all
power sources. It should not consume in total more than 35W of power
(approx.
5A current from a 7.2V power source). (<span style="font-weight: bold;">Note</span>: This is <span style="font-weight: bold;">not</span>
an easy requirement to meet if your hovercraft is too heavy. A heavy
hovercraft will require more power from the lifting motors, which
require bigger power supply and larger batteries, etc. So, keep your
design simple and light.)<br>
<br>
This hovercraft should be able
to detect and avoid any obstacle along its path. At the same time, it
is remote-controllable by a joystick attached to a wireless base
station. The base station should be able to collect and display all
instrumentation data related to the sensors/actuators on board the
hovercraft. For example, the hovercraft may deploy multiple
sonars for measuring distances away from obstacles and walls., a
digital compass to measure its orientation, a current sensor to report
its power consumption, etc.&nbsp; During development,&nbsp; the
wireless radio link could also be used for debugging purposes.<br>
<br>
One additional challenge is to design
such an semi-autonomous hovercraft which can clear the paper airplanes
on the 5th floor of the ECS building. Be creative!<br>
<br>
This hovercraft will be designed and developed in three stages (project
1 to project 3):<br>
<ol>
<li>a prototype manual control base station and a remote
station;</li>
<li>hovercraft and propulsion system design;</li>
<li>integration of manual and autonomous control.</li>
</ol>
</div>
<br>
<h2>* Learning Objectives for Project 1</h2>
<br>
<div style="text-align: justify;">The primary learning objective of
this
first project is
to get
you familiar with the Arduino Mega (Seeduino) board in general, the I/O
architecture
of ATMega1280&nbsp; chip and its software development tools
(Arduino library and Eclipse) in
particular. It is very important for everyone to read this <a href="handouts/references.html">laboratory reference</a>;
it contains many references that will help you in your endeavour.<br>
</div>
<br>
<div style="text-align: justify;">For
this project, you will
learn how our target board (an Arduino Mega) interfaces with a PS/2
gamepad joystick, a servo motor, two dc motors, two sonars, an IR proxmity
sensor, a color LED and
2 wireless 2.4GHz radios. You will be exposed to the
following I/O interface standard:<br>
</div>
<ul>

<li>A-D Convertor (IR proximity sensor)<br>
</li>
  <li>Pulse-Width Modulation (PWM) timers (DC motors or servo
motors
interface),</li>

<li>Digital Input with Input Captured timers (sonar interface),<br>
</li>
<li>I2C protocol (color LED interface),</li>
<li>SPI (synchronous serial interface for the radio),</li>
<li>UART (asynchronous serial interface) and USB (for
microcontroller to PC interface).<br></li>
</ul>
<h2>* Project 1 Problem</h2>
<div style="text-align: justify;">Imagine a freely rotating platform
sitting on a stationary ball-bearing. On the platform, there are two dc
motors with propellers
providing horizontal forward/reverse and turning motion, and&nbsp;two
front facing sonars
mounted on either end of the platform. We are using this platform to
simulate our hovercraft control problem. This platform can be
controlled in two different modes: <span style="font-weight: bold;">manual</span> or <span style="font-weight: bold;">automatic</span>.&nbsp;<br><br>In the manual mode, a remote PS/2 <span style="font-style: italic;">gamepad</span>&nbsp;
can control forward/reverse speed of two dc motors and the rotation
speed of the platform. The gamepad is wired to a&nbsp;<span style="font-style: italic;">base</span> station which transmits control commands to&nbsp; your rotating platform, the&nbsp;<span style="font-style: italic;">remote</span> station.<br><br>In
the automatic mode, the remote platform will implement a simple
feedback controller so that the platform is always facing a wall using
the sonars for measuring distances away from the wall and deviation
from being parallel to the wall. When there is <span style="font-style: italic;">no</span>
wall, i.e., the wall is further away than 50 cm (approx.), the platform
should remain stationary, not turning at all, but the motors may still
run at a constant speed to maintain forward motion.<br><br>Independent of manual or automatic mode, your remote platform should accept an "<span style="font-weight: bold;">emergency</span>" stop command which turns off all high current&nbsp;power supply to the motors.<br><span style="font-weight: bold;"><br></span><h2><span style="font-weight: bold;">* &nbsp;Approach</span></h2>We
recommend that you complete this in two stages. In the first stage, the
base station and the remote station (the platform) will be implemented
on the same Arduino board. When everything is working properly, then
separate the two stations and add the wireless radios.<br><span style="font-weight: bold;"><br>Base
station.</span>
Your base station (an Arduino board) is connected to a PC via USB
(which appears as a virtual COM port in Windows). Your gamepad is also
connected to a PC via USB, but it will appear as a "Gamepad" device.
Check your Windows Control Panel to test your gamepad. Make sure that
your gamepad is working properly.<br><br>There is a Python script which
reads the gamepad inputs (buttons and joysticks) using Windows driver
and outputs 4 bytes which encodes the statesof the joysticks and
buttons. Your Arduino board will get these data bytes via its UART
interface (the same UART port used for downloading and printing).<br><br>For
simple status display, we also provide you with an BlinkM
I2C&nbsp;color smart LED (which can display different intensity of RGB
at the
same time). &nbsp;You should learn how to use it . It is a simple
device to learn how I2C works.<br>
<span style="font-weight: bold;"><br>
Remote station</span>. This is
your rotating platform. You will be using two DC motors as actuators
and two sonars as sensors. &nbsp;You cannot drive DC motors directly
from the I/O pins of a microcontroller. You need to use an H-bridge
circuit to handle the extra current load, and to provide a simple
direction (forward/reverse) and speed control. For smaller motors
(under 1A current), we will use L293D. For larger motors (under 4A), we
will use L298D. &nbsp;Your microcontroller only needs to generate a PWM
signal to control &nbsp;the speed and to use a digital output pin to
control the direction. <br><br>A DC motor is an analog
actuator where its speed is proportional to
its supply voltage. By feeding a varying PWM (Pulse-Width Modulated)
signal to the motor, we can control&nbsp; the "average" supply
voltage,
thus its speed. We cannot drive a DC
motor directly from the I/O pins of an microcontroller due to its current
demand. A typical DC motor can draw upwards of few hundreds milliamps
or a few amps of current. An I/O pin of a typical microcontroller can
only source/sink a max. of 20 to 50 milliamps. So, we use a
separate motor power supply (7.2V) feeding a motor interface chip
(L298 or L293)
to drive a max. of two DC motors. The microcontroller will only require
to generate a PWM control (duty-cycle) signal using an internal timer. Its power supply (logic supply) is
independent of the motor power supply. (Note: It is a good practice to
separate the "logic" power supply from the noisy "motor" power supply,
and their associated ground.) Each L298/L293D chip basically consists of two
H-bridge MOSFET drivers; each H-bridge can drive a DC motor up a max.
of 2A/1A.<br><br>The
sonar can be interfaced in various ways. You may use it as a UART
device (the distance readings appeared as ASCII characters), as an
analog device (10mV per inch), or as a digital I/O device (captured the
rising and falling edge of a PWM signal). You are free to choose which
interface mode works best for your design. A sonar requires a 5V
power
source. When a sonar is triggered, it can generate noises in its power
supply. It is recommended to use a separate regulated power supply for
the sonars separated from the logic power supply.<br>
<br>
Alternative Design for the remote station: We also provide you with a
servo motor and an IR proximty sensor. You may incorporate these in
your design. For example, you may use a single DC motor for
forward/backward propulsion and use a servo motor for turning control.
You may use the IR proximity sensors instead of the sonars. <br>
<br>
</div>

<br>
<div style="text-align: justify;"><span style="font-weight: bold;">Communication</span>.
After you have completed the first stage, you are now ready to separate
&nbsp;the base and remote stations. You will add a 2-way (half-duplex,
i.e., walkie-talkie style) radio on each station connecting the two
together wirelessly. To avoid packet collision, one station should be programmed
as a <span style="font-weight: bold;">master</span> and the other as a <span style="font-weight: bold;">slave</span>.
The master should be in charge of the communication, i.e., the slave
should keep <span style="font-style: italic;">quiet</span>
until the master is asking for information. Thus, the
master station controls&nbsp; the overall rate of packet
transmission/reception between the two. The driver code for the radio
will be provided to you in the lab. There will be sample code to show
you how to configure your radio, a station address and an RF channel.<br><br><span style="font-weight: bold;">Debugging</span>.
For
instrumentation and debugging purposes, you need to collect and
display data on a PC workstation. The Arudino library already provides
standard "printf" support. You can easily display the collected data or
debugging information in a dumb terminal session using&nbsp;Teraterm or
Hyperterminal on the PC.</div>
<span style="font-weight: bold;"></span>



<h2>* Submission</h2>
<div style="text-align: justify;">Each team is required to
perform a
demonstration of their solution to
the project, and submit a final report of around 10-20 pages. The
report must include all aspects of your engineering design process to
arrive at your solution, e.g., analysis of the problem statement,
design approach, hardware architecture, hardware and software
interfaces, program listings and its internal documentation,
measurements, performance evaluations, observations, limitations,
references, etc. You may use digital pictures in your document to
illustrate details of your design. Please include your source code and
its documentation as well.<br>
</div>
<br>
<div style="text-align: justify;">Clarity and
understandability
of your design and solution are extremely
important, both hardware and software. The quality of your report and
your engineering process is a good indicator of whether your solution
is trustworthy, reliable, repeatable and predictable. The end result is
that other students/engineers may be able to learn from your ideas and
repeat them if necessary. So, please take this documentation and the
engineering process seriously. (For example, wirings of electronic
components should be neat and tidy; they should be labeled clearly in a
schematic diagram. Identifiers in your software should be chosen for
its purpose appropriately; there should be enough inline documentation
stating clearly how the functions and program variables relate to the
hardware components.)<br>
</div>
<br>
<div style="text-align: justify;">You will be evaluated
based on: <br>
<ul>
<li>(50%) documentation---what your team
has done, including overall design and architecture, schematics,
interfacing and wiring diagrams, principle of operations, and testing;<br>
</li>
<li>(30%) quality of the engineering design process---how you
go
about solving the problem; and <br>
</li>
<li>(20%) demonstration.</li>
</ul>
</div>
<div style="text-align: justify;">Please remember that
just
submitting a working solution without any
supporting evidence of how your team arrives at the solution won't
guarantee a good evaluation. On the other hand, <span style="font-style: italic;">failures are as
important as successes.</span> Your team can still receive a reasonable grade
even if your results are not as good as what you&nbsp;expected, as long
as you document clearly your design and engineering process and findings.<br>
</div>
<br>
<div style="text-align: justify;">You may use any report
format,
e.g., HTML, word document, PDF file,
etc. Submit it to the instructor by email on the due date.</div></body></html>